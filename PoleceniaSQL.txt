Stan produktu w magazynie nie może być mniejszy od 0. - Aktualizacja, tworzenie Produktu

CREATE TRIGGER [dbo].[ProductQuantity]
ON [dbo].[Products]
FOR  insert, update AS 
IF EXISTS (
        SELECT *
        FROM inserted i
        WHERE i.Quantity < 0)
BEGIN
	ROLLBACK
    RAISERROR ('Ilosc dodawanego produktu zawsze wieksza od zera', 11, 1)
END

Sprawdzenie:

INSERT INTO Products(Id, Name, Unit_price, Quantity)
VALUES (12,'Spodnie Addidas', 90.00, -1);

Nie można złożyć zamówienia na produkt kiedy jego stan wynosi 0. - aktualizacja, towrzenie Zamówienia

CREATE TRIGGER [dbo].[OrderQuantity]
ON [dbo].[OrderDetails]
FOR  insert, update AS 
IF EXISTS (
        SELECT *
        FROM inserted i, Products p
        WHERE p.Id = i.Product_id AND p.Quantity = 0)
BEGIN
	ROLLBACK
    RAISERROR ('Brak produktu na magazynie', 11, 1)
END

Po złożeniu zamówienia stan produktu na magazynie zmniejsza się w zaleznośći od ilości,
informacja o maksymalnym zamówieniu gdy przewyżsyzmy stan magazynowy. - aktualizacja, tworznei zamowienia

CREATE TRIGGER [dbo].[WarehouseQuantity]
ON [dbo].[OrderDetails]
FOR  insert, update AS 
IF EXISTS (
        SELECT *
        FROM inserted i, Products p
        WHERE p.Id = i.Product_id AND i.Quantity <= p.Quantity)
BEGIN
	UPDATE
	 Products 
	SET
	 Quantity = p.Quantity-i.Quantity
	FROM
	Products p ,inserted i 
	WHERE
	i.Product_id = p.Id
end
ELSE 
BEGIN
	
		DECLARE @ProductQuantity INT
		SElect @ProductQuantity = p.Quantity from inserted i, Products p WHERE p.Id = i.Product_id
		RAISERROR ('Nie wystarczająca ilość produktu na magazynie (maksymalna ilość %i)' , 11, 1, @ProductQuantity)
		ROLLBACK
END

PROCEDURO-TRIGGER

Obsłyga rabatów oraz darmowej przesyłki i tworzenia Payments na podstawie OrderDetails

CREATE   procedure [dbo].[InsertPayment]
(@order_id int)
as
begin
 declare @total_value float
 declare @delivery_cost int
 declare @discount int
 declare @pay_value float

 select  @total_value = sum(od.Quantity * p.Unit_price) from OrderDetails od, Products p Where od.Product_id = p.Id AND od.Order_id = @order_id;
 select  @delivery_cost = d.Unit_price from [Delivery types] d, Orders o where o.Id = @order_id AND d.Id = o.DeliveryType_id;
 
 if (@total_value >= 150.00 AND @total_value < 300)
	begin
	 select @delivery_cost = 0;
	 select @discount = 0;
	end

if (@total_value >= 300.00 AND @total_value < 500)
	begin
	 select @delivery_cost = 0;
	 select @discount = 10;
	end

if (@total_value >= 500)
	begin
	 select @delivery_cost = 0;
	 select @discount = 15;
	end
select  @pay_value = @delivery_cost + (@total_value*(100 - @discount))/100;
end
insert into Payments(Ord_id, Total_value, Delivery_cost, Discount, Pay_value)
values(@order_id, @total_value, @delivery_cost, @discount, @pay_value);

PROCEDURY

Historia zamówień klienta

drop procedure [ClientHistory];

CREATE   procedure [dbo].[ClientHistory]
@clientid int
as
begin
  Select o.OrderDate, p.Id As ProductId, p.Name from Products p, Orders o, OrderDetails od
  Where o.Client_id = @clientid AND o.Id = od.Order_id AND od.Product_id = p.Id
end

FUNKCJE

Ilość zamówień złozonych przez jednego klienta

CREATE FUNCTION  [dbo].[OrdersCount](@clientid int)
RETURNS INT
as
BEGIN 
	declare @count INT
   SELECT @count = count(*)
   FROM Orders o
   where o.Client_id = @clientid
   RETURN @count; 
END


Wartość wszytkich zamówień jakie złozył klient (na podstawie Orders a nie Payment)

CREATE FUNCTION  [dbo].[OrderWorth](@clientid int)
RETURNS FLOAT
as
BEGIN 
	declare @sum FLOAT
	select @sum = SUM(p.Unit_price * od.Quantity) 
   from Orders o, Products p, OrderDetails od
	where o.Client_id =@clientid AND od.Order_id = o.Id AND p.Id = od.Product_id
   RETURN @sum 
END

Całkowity przychód (na podstawie Orders a nie Payment)

CREATE FUNCTION  [dbo].[Income]()
RETURNS FLOAT
as
BEGIN 
	declare @sum FLOAT
	select @sum = SUM(p.Unit_price * od.Quantity) 
    from Orders o, Products p, OrderDetails od
	where  o.Id = od.Order_id AND p.Id = od.Product_id
   RETURN @sum 
END

BLOKOWANIE OPTYMISTYCZNE - procedura edit dla Products

CREATE   procedure [dbo].[ProductUpdate]
@productid int,
@name varchar(40),
@unitprice float,
@quantity int
as
begin
	declare @rowid rowversion

	select @rowid = rowid
	from Products
	where Id = @productid
	
	--waitfor delay '00:00:10'

	UPDATE Products
       SET Name = @name,
           Unit_price = @unitprice,
		   Quantity = @quantity
       WHERE Id = @productid
           AND rowid = @rowid;

	if @@ROWCOUNT = 0
		if not exists ( select * from Products where Id = @productid)
		RAISERROR ('Konflikt aktualizacji: Rekord z produktem został usunięty', 11, 1)
	else
		RAISERROR ('Konflikt aktualizacji: Rekord z produktem został zaktualizowany wcześniej', 11, 1)
end
